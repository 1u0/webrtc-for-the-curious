<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Why do I need a dedicated subsystem for connecting? #  WebRTC will go to great lengths to achieve direct bi-directional communication between two WebRTC Agents. These agents may even be in different networks with no direct communication between agents, by using NAT Traversal WebRTC can make communication happen. NAT Traversal is a networking technique that enables communication between two peers that can&rsquo;t directly connect.
In situations where direct connectivity doesn&rsquo;t exist and NAT Traversal fails WebRTC has other techniques."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Connecting"><meta property="og:description" content="Why do I need a dedicated subsystem for connecting? #  WebRTC will go to great lengths to achieve direct bi-directional communication between two WebRTC Agents. These agents may even be in different networks with no direct communication between agents, by using NAT Traversal WebRTC can make communication happen. NAT Traversal is a networking technique that enables communication between two peers that can&rsquo;t directly connect.
In situations where direct connectivity doesn&rsquo;t exist and NAT Traversal fails WebRTC has other techniques."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/docs/03-connecting/"><meta property="article:modified_time" content="2020-08-14T23:29:01-07:00"><title>Connecting | WebRTC for the Curious</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/en.search.min.795edf94ac341be99283c737dd16338e9fed5e7993f73d04e658189fb324297a.js integrity="sha256-eV7flKw0G+mSg8c33RYzjp/tXnmT9z0E5lgYn7MkKXo="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>WebRTC for the Curious</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/01-what-why-and-how/>What, Why and How</a></li><li><a href=/docs/02-signaling/>Signaling</a></li><li><a href=/docs/03-connecting/ class=active>Connecting</a></li><li><a href=/docs/04-securing/>Securing</a></li><li><a href=/docs/05-media-communication/>Media Communication</a></li><li><a href=/docs/06-data-communication/>Data Communication</a></li><li><a href=/docs/08-debugging/>Debugging</a></li><li><a href=/docs/09-history-of-webrtc/>History</a></li><li><a href=/docs/10-faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Connecting</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#why-do-i-need-a-dedicated-subsystem-for-connecting>Why do I need a dedicated subsystem for connecting?</a><ul><li><a href=#reduced-bandwidth-costs>Reduced Bandwidth Costs</a></li><li><a href=#lower-latency>Lower Latency</a></li><li><a href=#secure-e2e-communication>Secure E2E Communication</a></li></ul></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#networking-real-world-constraints>Networking real world constraints</a><ul><li><a href=#not-in-the-same-network>Not in the same network</a></li><li><a href=#protocol-restrictions>Protocol Restrictions</a></li><li><a href=#firewallids-rules>Firewall/IDS Rules</a></li></ul></li><li><a href=#nat-mapping>NAT Mapping</a><ul><li><a href=#creating-a-mapping>Creating a Mapping</a></li><li><a href=#mapping-creation-behaviors>Mapping Creation Behaviors</a></li><li><a href=#mapping-filtering-behaviors>Mapping Filtering Behaviors</a></li><li><a href=#mapping-refresh>Mapping Refresh</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protocol-structure>Protocol Structure</a></li><li><a href=#create-a-nat-mapping>Create a NAT Mapping</a></li><li><a href=#determining-nat-type>Determining NAT Type</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-lifecycle>TURN Lifecycle</a></li><li><a href=#turn-usage>TURN Usage</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=why-do-i-need-a-dedicated-subsystem-for-connecting>Why do I need a dedicated subsystem for connecting?
<a class=anchor href=#why-do-i-need-a-dedicated-subsystem-for-connecting>#</a></h2><p>WebRTC will go to great lengths to achieve direct bi-directional communication between two WebRTC Agents. These agents may even be in different networks with no direct communication between agents, by using NAT Traversal WebRTC can make communication happen. NAT Traversal is a networking technique that enables communication between two peers that can&rsquo;t directly connect.</p><p>In situations where direct connectivity doesn&rsquo;t exist and NAT Traversal fails WebRTC has other techniques. You can then use a TURN server to communicate across protocols (UDP &lt;-> TCP) and versions (IPv4 &lt;-> IPv6).</p><p>Because WebRTC has these attributes you get these advantages over traditional Client/Server technology.</p><h3 id=reduced-bandwidth-costs>Reduced Bandwidth Costs
<a class=anchor href=#reduced-bandwidth-costs>#</a></h3><p>Since media communication happens directly during peers you don&rsquo;t have to pay for transporting it.</p><h3 id=lower-latency>Lower Latency
<a class=anchor href=#lower-latency>#</a></h3><p>Communication is faster when it is direct! When a user had to run everything through you server it makes things slower.</p><h3 id=secure-e2e-communication>Secure E2E Communication
<a class=anchor href=#secure-e2e-communication>#</a></h3><p>Direct Communication is more secure. Since users aren&rsquo;t routing your data through your server they don&rsquo;t even need to trust you won&rsquo;t decrypt it.</p><h2 id=how-does-it-work>How does it work?
<a class=anchor href=#how-does-it-work>#</a></h2><p>The process described above is <a href=https://tools.ietf.org/html/rfc8445>ICE</a>. Another protocol that pre-dates WebRTC.</p><p>ICE is a protocol that tries to find the best way to communicate between two ICE Agents. Each ICE Agents publishes the ways it is reachable, these are known as candidates. ICE then determines the best candidate pairing of candidates.</p><p>The actual ICE Process is described in greater detail later in this chapter. To understand why ICE exists it is useful to understand what network behaviors were are overcoming.</p><h2 id=networking-real-world-constraints>Networking real world constraints
<a class=anchor href=#networking-real-world-constraints>#</a></h2><p>ICE is all about overcoming the constraints of real world networks. Before we even explore the solution lets talk about the actual problems.</p><h3 id=not-in-the-same-network>Not in the same network
<a class=anchor href=#not-in-the-same-network>#</a></h3><p>Most of the time the other WebRTC Agent will not even be in the same network. A typical call is usually between two WebRTC Agents in different networks with no direct connectivity.</p><p>Below is a graph of two distinct networks, connected by the public internet. Then in each network you have two hosts.</p><script src=/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:true}});</script><p class=mermaid>graph TB
subgraph netb ["Network B (IP Address 5.0.0.2)"]
b3["Agent 3 (IP 192.168.0.1)"]
b4["Agent 4 (IP 192.168.0.1)"]
routerb["Router B"]
end
subgraph neta ["Network A (IP Address 5.0.0.1)"]
routera["Router A"]
a1["Agent 1 (IP 192.168.0.1)"]
a2["Agent 2 (IP 192.168.0.1)"]
end
pub{Public Internet}
routera-->pub
routerb-->pub</p><p>For the hosts in the same network it is very easy to connect. <code>192.168.0.1 -> 192.168.0.2</code> is easy to do! However a host using <code>Router B</code> has no way to directly access anything using <code>Router A</code>. A host using <code>Router B</code> could send traffic directly to <code>Router A</code>, but the request would end there.</p><h3 id=protocol-restrictions>Protocol Restrictions
<a class=anchor href=#protocol-restrictions>#</a></h3><p>Some networks don&rsquo;t allow UDP traffic at all, or maybe they don&rsquo;t allow TCP. Some networks have a very low MTU. There are lots of variables that network administrators can change that can make communication difficult.</p><h3 id=firewallids-rules>Firewall/IDS Rules
<a class=anchor href=#firewallids-rules>#</a></h3><p>Another is &lsquo;Deep Packet Inspection&rsquo; and other intelligent filtering. Some network administrators will run software that tries to process every packet. Many times this software doesn&rsquo;t understand WebRTC, so blocks because it doesn&rsquo;t know what to do</p><h2 id=nat-mapping>NAT Mapping
<a class=anchor href=#nat-mapping>#</a></h2><p>NAT(Network Address Translation) Mapping is the magic that makes the connectivity of WebRTC possible, even when the peers can&rsquo;t access each other on their own. With this you can have two peers in completely different networks communicating directly.</p><p>Again we have a <code>Agent 1</code> and <code>Agent 2</code> and they are in different networks. However traffic is flowing completely through. Visualized that looks like.</p><p class=mermaid>graph TB
subgraph netb ["Network B (IP Address 5.0.0.2)"]
b2["Agent 2 (IP 192.168.0.1)"]
routerb["Router B"]
end
subgraph neta ["Network A (IP Address 5.0.0.1)"]
routera["Router A"]
a1["Agent 1 (IP 192.168.0.1)"]
end
pub{Public Internet}
a1-.->routera;
routera-.->pub;
pub-.->routerb;
routerb-.->b2;</p><p>To makes this possible you need to establish a NAT Mapping first. NAT mapping will feel like an automated/config-less version of doing port forwarding in your router.</p><p>The downside to NAT Mapping is that that network behavior is inconsistent between networks. ISPs and hardware manufacturers do it in different ways for their own reasons. In some cases network administrators may even disable it.
The full range of behaviors is understood and observable, so a ICE Agent is able to confirm it created a NAT Mapping, and the attributes of the mapping.</p><p>The document that describes these behaviors is <a href=https://tools.ietf.org/html/rfc4787>RFC 4787</a></p><h3 id=creating-a-mapping>Creating a Mapping
<a class=anchor href=#creating-a-mapping>#</a></h3><p>Creating a mapping is the easiest part. When you send a packet to an address outside your network, a mapping is created! If the server then responds to your request the response will be delivered back to the host that sent it.
The server can respond with multiple packets back to your single message.</p><p>The details around mappings is where it gets complicated.</p><h3 id=mapping-creation-behaviors>Mapping Creation Behaviors
<a class=anchor href=#mapping-creation-behaviors>#</a></h3><p>These are the rules for when a new mapping is created. They fall into three different categories.</p><h4 id=endpoint-independent-mapping>Endpoint Independent Mapping
<a class=anchor href=#endpoint-independent-mapping>#</a></h4><p>One mapping is created for each sender inside the NAT. If you send two packets to different remote addresses the NAT Mapping will be re-used. Both remote hosts could then respond and it would be sent back to the same local listener.</p><p>This is the best case scenario. For a call to work at least one side MUST be of this type.</p><h4 id=address-dependent-mapping>Address Dependent Mapping
<a class=anchor href=#address-dependent-mapping>#</a></h4><p>A new mapping is created every time you send to a new address. If you send two packets to different hosts two mappings will be created. If you send two packets to the same remote host, but different destination ports a new mapping will NOT be created.</p><h4 id=address-and-port-dependent-mapping>Address and Port Dependent Mapping
<a class=anchor href=#address-and-port-dependent-mapping>#</a></h4><p>A new mapping is created if the remote IP or Port is different. If you send two packets to the same remote host, but different destination ports a new mapping will be created.</p><h3 id=mapping-filtering-behaviors>Mapping Filtering Behaviors
<a class=anchor href=#mapping-filtering-behaviors>#</a></h3><p>Mapping filtering are the rules around who is allowed to use the mapping. They fall into three similar classifications.</p><h4 id=endpoint-independent-filtering>Endpoint Independent Filtering
<a class=anchor href=#endpoint-independent-filtering>#</a></h4><p>Anyone can use the mapping. After you create the mapping by sending a packet that mapping can be used by anyone on the internet.</p><h4 id=address-dependent-filtering>Address Dependent Filtering
<a class=anchor href=#address-dependent-filtering>#</a></h4><p>Only the host the mapping was created for can use the mapping. If you send a packet to host <code>A</code> it can respond back with as many packets as it wants. If host <code>B</code> attempts to send a packet to that mapping it will be ignored.</p><h4 id=address-and-port-dependent-filtering>Address and Port Dependent Filtering
<a class=anchor href=#address-and-port-dependent-filtering>#</a></h4><p>Only the host and port the mapping was created for can use the mapping. If you send a packet to host <code>A:5000</code> it can respond back with as many packets as it wants. If host <code>A:5001</code> attempts to send a packet to that mapping it will be ignored.</p><h3 id=mapping-refresh>Mapping Refresh
<a class=anchor href=#mapping-refresh>#</a></h3><p>It is recommended that if a mapping is unused for 5 minutes it should be destroyed. This is entirely up to the ISP or hardware manufacturer.</p><h2 id=stun>STUN
<a class=anchor href=#stun>#</a></h2><p>STUN(Session Traversal Utilities for NAT) is a protocol that was created just for working with NATs. This is another technology pre-dates WebRTC (and ICE!). It is defined by <a href=https://tools.ietf.org/html/rfc5389>RFC 5389</a> STUN defines the structure of packets we send over UDP. The STUN protocol is also used by ICE/TURN.</p><p>STUN is useful because it gives us all the details about our NAT Mappings. We are able to create them, but we have no idea what the address is! STUN not only gives you the ability to create a mapping, but then you get the details so you can share it with others so they can send traffic to you via the mapping you created.</p><p>Lets start with a basic description of STUN. Later it will be extended later for TURN and ICE usage. For now we are just going to describe the Request/Response flow to create a mapping and then how we get the details of it to share with others. This is what actually happens when you have a <code>stun:</code> server in your ICE urls.</p><h3 id=protocol-structure>Protocol Structure
<a class=anchor href=#protocol-structure>#</a></h3><p>Every STUN packets begins with a STUN header, with the following structure</p><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0 0|     STUN Message Type     |         Message Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic Cookie                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                     Transaction ID (96 bits)                  |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=stun-message-type>STUN Message Type
<a class=anchor href=#stun-message-type>#</a></h4><p>Each STUN packet has a type. For now we only care about the following. We make a request to a STUN server, and it responds with a different type.</p><ul><li>Binding Request - <code>0x0001</code></li><li>Binding Response - <code>0x0101</code></li></ul><h4 id=message-length>Message Length
<a class=anchor href=#message-length>#</a></h4><p>This is how long the <code>Data</code> section is. This section contains arbitrary data that is defined by the <code>Message Type</code></p><h4 id=magic-cookie>Magic Cookie
<a class=anchor href=#magic-cookie>#</a></h4><p>The fixed value <code>0x2112A442</code>, it helps distinguish STUN traffic from other protocols.</p><h4 id=transaction-id>Transaction ID
<a class=anchor href=#transaction-id>#</a></h4><p>96-bit identifier that uniquely identifies a request/response. This helps you pair up your requests and responses.</p><h4 id=data>Data
<a class=anchor href=#data>#</a></h4><p>Data will contain a list of STUN attributes. A STUN Attribute has the following structure.</p><pre><code>0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Type                  |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Value (variable)                ....
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>The <code>STUN Binding Request</code> uses no attributes.</p><p>The <code>STUN Binding Response</code> uses a <code>XOR-MAPPED-ADDRESS (0x0020)</code>. This attribute contains an IP/Port. This is the IP/Port of the NAT Mapping that is created!</p><h3 id=create-a-nat-mapping>Create a NAT Mapping
<a class=anchor href=#create-a-nat-mapping>#</a></h3><p>Creating a NAT Mapping using STUN just takes sending one request! You send a <code>STUN Binding Request</code> to the STUN Server. The STUN Server then responds with a <code>STUN Binding Response</code>.
This <code>STUN Binding Response</code> will contain the <code>Mapped Address</code>. This <code>Mapped Address</code> is what you would share if someone wanted to send packets to you.</p><p>This how a <code>Server Reflexive Candidate</code> is generated also known as your <code>Public IP</code>.</p><h3 id=determining-nat-type>Determining NAT Type
<a class=anchor href=#determining-nat-type>#</a></h3><p>Unfortunately the <code>Mapped Address</code> might not be useful in all cases. If it is <code>Address Dependent</code> only the STUN server can send traffic back to you, making it useless for communicating with others.</p><p><a href=https://tools.ietf.org/html/rfc5780>RFC5780</a> defines a method for running a test to determine your NAT Type. This would be useful because you would know ahead of time if direct connectivity was possible, or if you need to use a TURN Server.</p><h2 id=turn>TURN
<a class=anchor href=#turn>#</a></h2><p>TURN (Traversal Using Relays around NAT) is defined in <a href=https://tools.ietf.org/html/rfc5766>RFC5766</a> is the solution when direct connectivity isn&rsquo;t possible. It could be because you have two NAT Types that are incompatible, or maybe can&rsquo;t speak the same protocol! TURN is also important for privacy purposes. By running all your communication through TURN you obscure the clients actual address.</p><p>TURN uses a dedicated server. This server acts as a proxy for a client. The client connects to a TURN Server and creates an <code>Allocation</code>. By creating a <code>Allocation</code> a client gets a temporary IP/Port/Protocol that can send into to get traffic back to the client.
This new listener is known as the <code>Relayed Transport Address</code>. Think of it like a forwarding address, you give this out so others can send you traffic via TURN! For each user you give the <code>Relay Transport Address</code> you must create a &lsquo;Permission&rsquo; for.</p><p>When you send outbound traffic via TURN it is sent via the <code>Relayed Transport Address</code>. When a remote peer gets traffic they see it coming from the TURN Server.</p><h3 id=turn-lifecycle>TURN Lifecycle
<a class=anchor href=#turn-lifecycle>#</a></h3><p>The following is everything that a client who wishes to create a TURN allocation has to do. Communicating with someone who is using TURN requires no changes though, you get a IP/Port and communicate with it like any other host.</p><h4 id=allocations>Allocations
<a class=anchor href=#allocations>#</a></h4><p>Allocations are at the core of TURN. A Allocation is basically a &lsquo;TURN Session&rsquo;. To create a TURN allocation you communicate with the TURN <code>Server Transport Address</code> (usually 3478)</p><p>When creating an allocation you need to provide/decide the following</p><ul><li>Username/Password - Creating TURN allocations require authentication</li><li>Allocation Transport - The <code>Relayed Transport Address</code> can be UDP or TCP</li><li>Even-Port - You can request sequential ports for multiple allocations, not relevant for WebRTC</li></ul><p>If the request succeeded you get a response with the TURN Server with the follow STUN Attributes in the Data section.</p><ul><li><code>XOR-MAPPED-ADDRESS</code> - <code>Mapped Address</code> of the <code>TURN Client</code>. When someone sends data to the <code>Relayed Transport Address</code> this is where it is forwarded too.</li><li><code>RELAYED-ADDRESS</code> - This is the address that you give out to other clients. If someone sends a packet to this address it is relayed to the TURN Client.</li><li><code>LIFETIME</code> - How long until this TURN Allocation is destroyed. You can extend the lifetime by sending a <code>Refresh</code> request.</li></ul><h4 id=permissions>Permissions
<a class=anchor href=#permissions>#</a></h4><p>A remote host can&rsquo;t send into your <code>Relayed Transport Address</code> until you create a permission for them. When you create a permission you are telling the TURN server that this IP/Port is allowed to send inbound traffic.</p><p>The remote host needs to give you the IP/Port as it appears to the TURN server. This means it should send a <code>STUN Binding Request</code> to the TURN Server. A common error case is that a remote host will send a <code>STUN Binding Request</code> to a different Server. They will then ask you to create a permission for this IP.</p><p>If they are behind a <code>Address Dependent Mapping</code> using a different server for getting the &lsquo;Mapping Address&rsquo; and communicating with TURN will fail! The &lsquo;Mapping Address&rsquo; will be different for the two servers, so it is important to do both on the same server.</p><h4 id=sendindicationchanneldata>SendIndication/ChannelData
<a class=anchor href=#sendindicationchanneldata>#</a></h4><p>These two messages are for the TURN Client to send messages to a remote peer.</p><p>SendIndication is a self contained message. Inside it is the data you wish to send, and who you wish to send it too. This is wasteful if you are sending a lot of messages to a remote peer. If you send 1,000 messages you will repeat their IP Address 1,000 times!</p><p>ChannelData allows you to send data, but not repeat an IP Address. You create a Channel with a IP/Port. You then send with the ChannelId, and the IP/Port is populated. This is the better choice if you are sending lots of messages.</p><h4 id=refreshing>Refreshing
<a class=anchor href=#refreshing>#</a></h4><p>Allocations will destroy themselves automatically. The TURN Client must refresh them sooner then the <code>LIFETIME</code> given when creating the allocation.</p><h3 id=turn-usage>TURN Usage
<a class=anchor href=#turn-usage>#</a></h3><p>TURN Usage exists in two forms. Usually you have one peer acting as a &lsquo;TURN Client&rsquo; and the other side communicating directly. In bad cases you might have TURN Usage on both sides because of improper setup.</p><p>These diagrams help illustrate what that would look like.</p><h4 id=one-turn-allocations-for-communication>One TURN Allocations for Communication
<a class=anchor href=#one-turn-allocations-for-communication>#</a></h4><p class=mermaid>graph TB
subgraph turn ["TURN Allocation"]
serverport["Server Transport Address"]
relayport["Relayed Transport Address" ]
end
turnclient{TURN Client}
peer{UDP Client}
turnclient-->|"ChannelData (To UDP Client)"|serverport
serverport-->|"ChannelData (From UDP Client)"|turnclient
peer-->|"Raw Network Traffic (To TURN Client)"|relayport
relayport-->|"Raw Network Traffic (To UDP Client)"|peer</p><h4 id=two-turn-allocations-for-communication>Two TURN Allocations for Communication
<a class=anchor href=#two-turn-allocations-for-communication>#</a></h4><p class=mermaid>graph TB
subgraph turna["TURN Allocation A"]
serverportA["Server Transport Address"]
relayportA["Relayed Transport Address" ]
end
subgraph turnb["TURN Allocation B"]
serverportB["Server Transport Address"]
relayportB["Relayed Transport Address" ]
end
turnclientA{TURN Client A}
turnclientB{TURN Client B}
turnclientA-->|"ChannelData"|serverportA
serverportA-->|"ChannelData"|turnclientA
turnclientB-->|"ChannelData"|serverportB
serverportB-->|"ChannelData"|turnclientB
relayportA-->|"Raw Network Traffic"|relayportB
relayportB-->|"Raw Network Traffic"|relayportA</p><h2 id=ice>ICE
<a class=anchor href=#ice>#</a></h2><p>ICE (Interactive Connectivity Establishment)</p><h3 id=candidate-gathering>Candidate Gathering
<a class=anchor href=#candidate-gathering>#</a></h3><h4 id=host>Host
<a class=anchor href=#host>#</a></h4><h4 id=host-mdns>Host (mDNS)
<a class=anchor href=#host-mdns>#</a></h4><h4 id=server-reflexive>Server Reflexive
<a class=anchor href=#server-reflexive>#</a></h4><h4 id=relay>Relay
<a class=anchor href=#relay>#</a></h4><h3 id=connectivity-checks>Connectivity Checks
<a class=anchor href=#connectivity-checks>#</a></h3><h4 id=peer-reflexive-candidates>Peer Reflexive Candidates
<a class=anchor href=#peer-reflexive-candidates>#</a></h4><h3 id=candidate-selection>Candidate Selection
<a class=anchor href=#candidate-selection>#</a></h3></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/d8483d6eb2347a42ad5e01598861019d4527c67a title="Last modified by Sean DuBois | August 15, 2020" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 15, 2020</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content//docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#why-do-i-need-a-dedicated-subsystem-for-connecting>Why do I need a dedicated subsystem for connecting?</a><ul><li><a href=#reduced-bandwidth-costs>Reduced Bandwidth Costs</a></li><li><a href=#lower-latency>Lower Latency</a></li><li><a href=#secure-e2e-communication>Secure E2E Communication</a></li></ul></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#networking-real-world-constraints>Networking real world constraints</a><ul><li><a href=#not-in-the-same-network>Not in the same network</a></li><li><a href=#protocol-restrictions>Protocol Restrictions</a></li><li><a href=#firewallids-rules>Firewall/IDS Rules</a></li></ul></li><li><a href=#nat-mapping>NAT Mapping</a><ul><li><a href=#creating-a-mapping>Creating a Mapping</a></li><li><a href=#mapping-creation-behaviors>Mapping Creation Behaviors</a></li><li><a href=#mapping-filtering-behaviors>Mapping Filtering Behaviors</a></li><li><a href=#mapping-refresh>Mapping Refresh</a></li></ul></li><li><a href=#stun>STUN</a><ul><li><a href=#protocol-structure>Protocol Structure</a></li><li><a href=#create-a-nat-mapping>Create a NAT Mapping</a></li><li><a href=#determining-nat-type>Determining NAT Type</a></li></ul></li><li><a href=#turn>TURN</a><ul><li><a href=#turn-lifecycle>TURN Lifecycle</a></li><li><a href=#turn-usage>TURN Usage</a></li></ul></li><li><a href=#ice>ICE</a><ul><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li></ul></li></ul></nav></aside></main></body></html>