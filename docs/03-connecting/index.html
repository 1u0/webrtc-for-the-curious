<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Why do I need a dedicated subsystem for connecting? #  WwbRTC will go to great lengths to achieve direct bi-directional communication between two WebRTC Agents. These agents may even be in different networks with no direct communication between agents, by using NAT Traversal WebRTC can make communication happen. NAT Traversal is a networking technique that enables communication between two peers that can&rsquo;t directly connect.
In situations where direct connectivity doesn&rsquo;t exist and NAT Traversal fails WebRTC has other techniques."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Connecting"><meta property="og:description" content="Why do I need a dedicated subsystem for connecting? #  WwbRTC will go to great lengths to achieve direct bi-directional communication between two WebRTC Agents. These agents may even be in different networks with no direct communication between agents, by using NAT Traversal WebRTC can make communication happen. NAT Traversal is a networking technique that enables communication between two peers that can&rsquo;t directly connect.
In situations where direct connectivity doesn&rsquo;t exist and NAT Traversal fails WebRTC has other techniques."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/docs/03-connecting/"><meta property="article:modified_time" content="2020-08-11T21:43:10-07:00"><title>Connecting | WebRTC for the Curious</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/en.search.min.a320f9fb2c51179ee14d04bde82170dcd57d1a4e18f617360f4722d31e59e974.js integrity="sha256-oyD5+yxRF57hTQS96CFw3NV9Gk4Y9hc2D0ci0x5Z6XQ="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>WebRTC for the Curious</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/01-what-why-and-how/>What, Why and How</a></li><li><a href=/docs/02-signaling/>Signaling</a></li><li><a href=/docs/03-connecting/ class=active>Connecting</a></li><li><a href=/docs/04-securing/>Securing</a></li><li><a href=/docs/05-media-communication/>Media Communication</a></li><li><a href=/docs/06-data-communication/>Data Communication</a></li><li><a href=/docs/08-debugging/>Debugging</a></li><li><a href=/docs/09-history-of-webrtc/>History</a></li><li><a href=/docs/10-faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Connecting</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#why-do-i-need-a-dedicated-subsystem-for-connecting>Why do I need a dedicated subsystem for connecting?</a><ul><li><a href=#reduced-bandwidth-costs>Reduced Bandwidth Costs</a></li><li><a href=#lower-latency>Lower Latency</a></li><li><a href=#secure-e2e-communication>Secure E2E Communication</a></li></ul></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#networking-real-world-constraints>Networking real world constraints</a><ul><li><a href=#not-in-the-same-network>Not in the same network</a></li><li><a href=#protocol-restrictions>Protocol Restrictions</a></li><li><a href=#firewallids-rules>Firewall/IDS Rules</a></li></ul></li><li><a href=#network-address-translation-and-addressport-mapping>Network Address Translation and Address/Port Mapping</a><ul><li><a href=#creating-a-mapping>Creating a Mapping</a></li><li><a href=#mapping-creation-behaviors>Mapping Creation Behaviors</a></li><li><a href=#mapping-filtering-behaviors>Mapping Filtering Behaviors</a></li><li><a href=#mapping-lifetimes>Mapping Lifetimes</a></li></ul></li><li><a href=#stun->STUN ()</a></li><li><a href=#turn->TURN ()</a></li><li><a href=#ice->ICE ()</a><ul><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=why-do-i-need-a-dedicated-subsystem-for-connecting>Why do I need a dedicated subsystem for connecting?
<a class=anchor href=#why-do-i-need-a-dedicated-subsystem-for-connecting>#</a></h2><p>WwbRTC will go to great lengths to achieve direct bi-directional communication between two WebRTC Agents. These agents may even be in different networks with no direct communication between agents, by using NAT Traversal WebRTC can make communication happen. NAT Traversal is a networking technique that enables communication between two peers that can&rsquo;t directly connect.</p><p>In situations where direct connectivity doesn&rsquo;t exist and NAT Traversal fails WebRTC has other techniques. You can then use a TURN server to communicate across protocols (UDP &lt;-> TCP) and versions (IPv4 &lt;-> IPv6).</p><p>Because WebRTC has these attributes you get these advantages over traditional Client/Server technology.</p><h3 id=reduced-bandwidth-costs>Reduced Bandwidth Costs
<a class=anchor href=#reduced-bandwidth-costs>#</a></h3><p>Since media communication happens directly during peers you don&rsquo;t have to pay for transporting it.</p><h3 id=lower-latency>Lower Latency
<a class=anchor href=#lower-latency>#</a></h3><p>Communication is faster when it is direct! When a user had to run everything through you server it makes things slower.</p><h3 id=secure-e2e-communication>Secure E2E Communication
<a class=anchor href=#secure-e2e-communication>#</a></h3><p>Direct Communication is more secure. Since users aren&rsquo;t routing your data through your server they don&rsquo;t even need to trust you won&rsquo;t decrypt it.</p><h2 id=how-does-it-work>How does it work?
<a class=anchor href=#how-does-it-work>#</a></h2><p>The process described above is <a href=https://tools.ietf.org/html/rfc8445>ICE</a>. Another protocol that pre-dates WebRTC.</p><p>ICE is a protocol that tries to find the best way to communicate between two ICE Agents. Each ICE Agents publishes the ways it is reachable, these are known as candidates. ICE then determines the best candidate pairing of candidates.</p><p>The actual ICE Process is described in greater detail later in this chapter. To understand why ICE exists it is useful to understand what network behaviors were are overcoming.</p><h2 id=networking-real-world-constraints>Networking real world constraints
<a class=anchor href=#networking-real-world-constraints>#</a></h2><p>ICE is all about overcoming the constraints of real world networks. Before we even explore the solution lets talk about the actual problems.</p><h3 id=not-in-the-same-network>Not in the same network
<a class=anchor href=#not-in-the-same-network>#</a></h3><p>Most of the time the other WebRTC Agent will not even be in the same network. A typical call is usually between two WebRTC Agents in different networks with no direct connectivity.</p><p>Below is a graph of two distinct networks, connected by the public internet. Then in each network you have two hosts.</p><script src=/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:true}});</script><p class=mermaid>graph TB
subgraph netb ["Network B (IP Address 5.0.0.2)"]
b3["Agent 3 (IP 192.168.0.1)"]
b4["Agent 4 (IP 192.168.0.1)"]
routerb["Router B"]
end
subgraph neta ["Network A (IP Address 5.0.0.1)"]
routera["Router A"]
a1["Agent 1 (IP 192.168.0.1)"]
a2["Agent 2 (IP 192.168.0.1)"]
end
pub{Public Internet}
routera-->pub
routerb-->pub</p><p>For the hosts in the same network it is very easy to connect. <code>192.168.0.1 -> 192.168.0.2</code> is easy to do! However a host using <code>Router B</code> has no way to directly access anything using <code>Router A</code>. A host using <code>Router B</code> could send traffic directly to <code>Router A</code>, but the request would end there.</p><h3 id=protocol-restrictions>Protocol Restrictions
<a class=anchor href=#protocol-restrictions>#</a></h3><p>Some networks don&rsquo;t allow UDP traffic at all, or maybe they don&rsquo;t allow TCP. Some networks have a very low MTU. There are lots of variables that network administrators can change that can make communication difficult.</p><h3 id=firewallids-rules>Firewall/IDS Rules
<a class=anchor href=#firewallids-rules>#</a></h3><p>Another is &lsquo;Deep Packet Inspection&rsquo; and other intelligent filtering. Some network administrators will run software that tries to process every packet. Many times this software doesn&rsquo;t understand WebRTC, so blocks because it doesn&rsquo;t know what to do</p><h2 id=network-address-translation-and-addressport-mapping>Network Address Translation and Address/Port Mapping
<a class=anchor href=#network-address-translation-and-addressport-mapping>#</a></h2><p>NAT Mapping is the magic that makes the connectivity of WebRTC possible, even when the peers can&rsquo;t access each other on their own. With this you can have two peers in completely different networks communicating directly.</p><p>Again we have a <code>Agent 1</code> and <code>Agent 2</code> and they are in different networks. However traffic is flowing completely through. Visualized that looks like.</p><p class=mermaid>graph TB
subgraph netb ["Network B (IP Address 5.0.0.2)"]
b2["Agent 2 (IP 192.168.0.1)"]
routerb["Router B"]
end
subgraph neta ["Network A (IP Address 5.0.0.1)"]
routera["Router A"]
a1["Agent 1 (IP 192.168.0.1)"]
end
pub{Public Internet}
a1-.->routera;
routera-.->pub;
pub-.->routerb;
routerb-.->b2;</p><p>To makes this possible you need to establish a NAT Mapping first. NAT mapping will feel like an automated/config-less version of doing port forwarding in your router.</p><p>The downside to NAT Mapping is that that network behavior is inconsistent between networks. ISPs and hardware manufacturers do it in different ways for their own reasons. In some cases network administrators may even disable it.
The full range of behaviors is understood and observable, so a ICE Agent is able to confirm it created a NAT Mapping, and the attributes of the mapping.</p><h3 id=creating-a-mapping>Creating a Mapping
<a class=anchor href=#creating-a-mapping>#</a></h3><h3 id=mapping-creation-behaviors>Mapping Creation Behaviors
<a class=anchor href=#mapping-creation-behaviors>#</a></h3><h3 id=mapping-filtering-behaviors>Mapping Filtering Behaviors
<a class=anchor href=#mapping-filtering-behaviors>#</a></h3><h3 id=mapping-lifetimes>Mapping Lifetimes
<a class=anchor href=#mapping-lifetimes>#</a></h3><h2 id=stun->STUN ()
<a class=anchor href=#stun->#</a></h2><h2 id=turn->TURN ()
<a class=anchor href=#turn->#</a></h2><h2 id=ice->ICE ()
<a class=anchor href=#ice->#</a></h2><h3 id=candidate-gathering>Candidate Gathering
<a class=anchor href=#candidate-gathering>#</a></h3><h4 id=host>Host
<a class=anchor href=#host>#</a></h4><h4 id=host-mdns>Host (mDNS)
<a class=anchor href=#host-mdns>#</a></h4><h4 id=server-reflexive>Server Reflexive
<a class=anchor href=#server-reflexive>#</a></h4><h4 id=relay>Relay
<a class=anchor href=#relay>#</a></h4><h3 id=connectivity-checks>Connectivity Checks
<a class=anchor href=#connectivity-checks>#</a></h3><h4 id=peer-reflexive-candidates>Peer Reflexive Candidates
<a class=anchor href=#peer-reflexive-candidates>#</a></h4><h3 id=candidate-selection>Candidate Selection
<a class=anchor href=#candidate-selection>#</a></h3></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/9bffea740a487f18f90c68d71422ba7a1316f5ae title="Last modified by Sean DuBois | August 12, 2020" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>August 12, 2020</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content//docs/03-connecting.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#why-do-i-need-a-dedicated-subsystem-for-connecting>Why do I need a dedicated subsystem for connecting?</a><ul><li><a href=#reduced-bandwidth-costs>Reduced Bandwidth Costs</a></li><li><a href=#lower-latency>Lower Latency</a></li><li><a href=#secure-e2e-communication>Secure E2E Communication</a></li></ul></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#networking-real-world-constraints>Networking real world constraints</a><ul><li><a href=#not-in-the-same-network>Not in the same network</a></li><li><a href=#protocol-restrictions>Protocol Restrictions</a></li><li><a href=#firewallids-rules>Firewall/IDS Rules</a></li></ul></li><li><a href=#network-address-translation-and-addressport-mapping>Network Address Translation and Address/Port Mapping</a><ul><li><a href=#creating-a-mapping>Creating a Mapping</a></li><li><a href=#mapping-creation-behaviors>Mapping Creation Behaviors</a></li><li><a href=#mapping-filtering-behaviors>Mapping Filtering Behaviors</a></li><li><a href=#mapping-lifetimes>Mapping Lifetimes</a></li></ul></li><li><a href=#stun->STUN ()</a></li><li><a href=#turn->TURN ()</a></li><li><a href=#ice->ICE ()</a><ul><li><a href=#candidate-gathering>Candidate Gathering</a></li><li><a href=#connectivity-checks>Connectivity Checks</a></li><li><a href=#candidate-selection>Candidate Selection</a></li></ul></li></ul></nav></aside></main></body></html>