'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/introduction/','title':"Introduction",'section':"Docs",'content':"What is this book. #  WebRTC for the curious is an Open Source book written for those that are always looking for more. This book was created by WebRTC implementors to share their hard earned knowledge about WebRTC with the world.\nThis book is all about protocols and APIs. We want to cover all the things that the tutorials have missed. If you are interested in learning about the Javascript API or some other particular software this book might not be the best resource.\nThis book is for when that thorny production issue hits, or when you are about to ship your one of a kind idea. You will be armed with the knowledge to debug every piece of WebRTC.\nLicense #  This book is available under the CC0 license. The authors have waived all their copyright and related rights in their works to the fullest extent allowed by law. You May use this work however you want and no attribution is required.\nThe only intention of this book is to make the world a better place. WebRTC is a wonderful technology but is difficult to use. Politics and commercial interests have made it more difficult then it needs to be.\n"});index.add({'id':1,'href':'/docs/01-what-why-and-how/','title':"What, Why and How",'section':"Docs",'content':"What is WebRTC. #  WebRTC is both an API and Protocol. The WebRTC protocol is a set of rules for two agents to negotiate bi-directional secure communication. The WebRTC API was designed just for Javascript. This Javascript API then allows web developers to use the WebRTC protocol in the browser.\nA similar relationship would be HTTP and the fetch API. WebRTC the protocol would be HTTP, and WebRTC the API would be the fetch API.\nMany other APIs besides Javascript, servers and tools exist for WebRTC. All of these implementations can interact with each others.\nWhy should I learn WebRTC? #  These are the things that WebRTC will give you. This list is not exhaustive but is some of the things you may appreciate during your journey. Don\u0026rsquo;t worry if you don\u0026rsquo;t know some of these terms yet, this book will teach you them along tne way.\n Open Standard Multiple Implementations Available in Browsers Mandatory Encryption NAT Traversal Repurposed existing technology Congestion Control Sub-Second Latency  How does WebRTC (the protocol) Work #  This is a question that takes an entire book to explain. However, to start off we break it into four steps.\n Signaling Connecting Securing Communicating  These four steps happen sequentially. The prior step must be 100% successful for the subsequent one to even begun. At a high level this is what each one of these steps is accomplishing.\nOne pecuilar fact about WebRTC is that it actually made up of many other protocols! To make WebRTC we stitch together many existing technologies. In that sense WebRTC is more a combination and configuration of well understood tech that has been around since the early 2000s.\nEach of these steps have dedicated chapters, but it is helpful to understand them at a high level first. Since they are dependant on each other it will help explain each steps purpose more.\nSignaling #  When a WebRTC Agent starts it has no idea who it is going to communicate with and what they are going to communicate about. Signaling solves this issue! Signaling is used to bootstrap the call so that the two WebRTC agents can start communicating directly.\nSignaling uses an existing protocol SDP. SDP is a plain text buffee made up off key/value pairs and contains a list of \u0026lsquo;media sections\u0026rsquo;. The SDP that the two WebRTC Agents exchange contains details like.\n IPs and Ports that the agent is reachable on (candidates) How many audio and video tracks the agent wishes to send What audio and video codecs the agent supports Values used while connecting (uFrag/uPwd) Values used while securing (certificate fingerprint)  Connecting #  The two WebRTC Agents now know enough details to attempt to connect to each other. WebRTC again uses an existing technology called ICE.\nICE (Interactive Connectivity Establishment) is a protocol that pre-dates WebRTC. ICE allows the establishment of a connection between two Agents. These Agents could be in the same network, or on the other side if the world. ICE is the solution to establishing a direct connection without a central server.\nThe real magic here is \u0026lsquo;NAT Traversal\u0026rsquo; and TURN Servers. These two concepts all you to communicate with an IP/Port that you can\u0026rsquo;t connect to because it\u0026rsquo;s in another subnet. We will explore these topics in depth later.\nOnce ICE successfully connects, WebRTC then moves on to establishing an encrypted transport. This transport is used for the audio, video and data.\nSecuring #  Now that we have bi-directional communication (via ICE) we need to establish secure communication. This is done through two protocols that pre-date WebRTC. The first protocol is DTLS (Datagram Transport Layer Security) which is just TLS over UDP. TLS is the technology that powers HTTPS. The second protocol is SRTP (Secure Real-time Transport Protocol).\nFirst WebRTC connects by doing a DTLS handshake over the connection established by ICE. Unlike HTTPS WebRTC doesnt use a central authority for certificates. Instead WebRTC just asserts that the certificate exchanged via DTLS matches the the fingerprint shared via signaling. This DTLS connection is then used for DataChannel messages.\nWebRTC then uses a different protocol for audio/video transmission called RTP. We secure our RTP packets using SRTP. We initialize our SRTP session by extracting the keys from the negotiated DTLS session. In a later chapter why media transmission has its own protocol.\nWe are done! You now have bi-directional and secure communication. If you have a stable connection between your WebRTC Agents this is all the complexity you may need. Unfortunately the real world has packet loss and bandwidth limits, and the next section is about how we deal with them.\nCommunicating #  How does WebRTC (the API) work #  This section is not an exhaustive demo of the WebRTC API. Instead we are going to show how common usage of the API maps to the WebRTC protocol.\n AddTrack creates SDP entry. Packets sent via RTP onICEConnectionStateChange comes from ICE Agent   "});index.add({'id':2,'href':'/docs/02-signaling/','title':"Signaling",'section':"Docs",'content':"Signaling #  Signaling is the act of exchanging attributes and capabilities of the two WebRTC clients. When you start a WebRTC call these\n"});index.add({'id':3,'href':'/docs/03-connecting/','title':"Connecting",'section':"Docs",'content':"Connecting #  Networking Basics #  NATs #  ICE #  "});index.add({'id':4,'href':'/docs/04-securing/','title':"Securing",'section':"Docs",'content':"Securing #  DTLS #  SRTP #  "});index.add({'id':5,'href':'/docs/05-media-communication/','title':"Media Communication",'section':"Docs",'content':"Audio and Video Communication #  RTP/RTCP #  Protocol Basics Loss and Error Resilience Congestion Control\n"});index.add({'id':6,'href':'/docs/06-data-communication/','title':"Data Communication",'section':"Docs",'content':"SCTP #  "});index.add({'id':8,'href':'/docs/08-debugging/','title':"Debugging",'section':"Docs",'content':"Debugging #  Reduce Surface Area #  Network Debugging #  Media Debugging #  Data Debugging #  "});index.add({'id':9,'href':'/docs/09-history-of-webrtc/','title':"History",'section':"Docs",'content':"History #  This section is ongoing and we donâ€™t have all the facts yet. We are conducting interviews and build a history of digital communication.\nPre-RTP #  RTP #  SDP #  ICE #  SRTP #  SCTP #  DTLS #  "});})();